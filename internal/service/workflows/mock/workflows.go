// Code generated by MockGen. DO NOT EDIT.
// Source: workflows.go
//
// Generated by this command:
//
//	mockgen -source=workflows.go -package=workflows -destination=./mock/workflows.go
//

// Package workflows is a generated GoMock package.
package workflows

import (
	context "context"
	reflect "reflect"
	time "time"

	jobs "github.com/hitesh22rana/chronoverse/internal/model/jobs"
	workflows "github.com/hitesh22rana/chronoverse/internal/model/workflows"
	gomock "go.uber.org/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
	isgomock struct{}
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// CreateWorkflow mocks base method.
func (m *MockRepository) CreateWorkflow(ctx context.Context, userID, name, payload, kind string, interval, maxConsecutiveJobFailuresAllowed int32) (*workflows.GetWorkflowResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateWorkflow", ctx, userID, name, payload, kind, interval, maxConsecutiveJobFailuresAllowed)
	ret0, _ := ret[0].(*workflows.GetWorkflowResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateWorkflow indicates an expected call of CreateWorkflow.
func (mr *MockRepositoryMockRecorder) CreateWorkflow(ctx, userID, name, payload, kind, interval, maxConsecutiveJobFailuresAllowed any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWorkflow", reflect.TypeOf((*MockRepository)(nil).CreateWorkflow), ctx, userID, name, payload, kind, interval, maxConsecutiveJobFailuresAllowed)
}

// DeleteWorkflow mocks base method.
func (m *MockRepository) DeleteWorkflow(ctx context.Context, workflowID, userID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteWorkflow", ctx, workflowID, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteWorkflow indicates an expected call of DeleteWorkflow.
func (mr *MockRepositoryMockRecorder) DeleteWorkflow(ctx, workflowID, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWorkflow", reflect.TypeOf((*MockRepository)(nil).DeleteWorkflow), ctx, workflowID, userID)
}

// GetWorkflow mocks base method.
func (m *MockRepository) GetWorkflow(ctx context.Context, workflowID, userID string) (*workflows.GetWorkflowResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkflow", ctx, workflowID, userID)
	ret0, _ := ret[0].(*workflows.GetWorkflowResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkflow indicates an expected call of GetWorkflow.
func (mr *MockRepositoryMockRecorder) GetWorkflow(ctx, workflowID, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkflow", reflect.TypeOf((*MockRepository)(nil).GetWorkflow), ctx, workflowID, userID)
}

// GetWorkflowByID mocks base method.
func (m *MockRepository) GetWorkflowByID(ctx context.Context, workflowID string) (*workflows.GetWorkflowByIDResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkflowByID", ctx, workflowID)
	ret0, _ := ret[0].(*workflows.GetWorkflowByIDResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkflowByID indicates an expected call of GetWorkflowByID.
func (mr *MockRepositoryMockRecorder) GetWorkflowByID(ctx, workflowID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkflowByID", reflect.TypeOf((*MockRepository)(nil).GetWorkflowByID), ctx, workflowID)
}

// IncrementWorkflowConsecutiveJobFailuresCount mocks base method.
func (m *MockRepository) IncrementWorkflowConsecutiveJobFailuresCount(ctx context.Context, workflowID, userID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IncrementWorkflowConsecutiveJobFailuresCount", ctx, workflowID, userID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IncrementWorkflowConsecutiveJobFailuresCount indicates an expected call of IncrementWorkflowConsecutiveJobFailuresCount.
func (mr *MockRepositoryMockRecorder) IncrementWorkflowConsecutiveJobFailuresCount(ctx, workflowID, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IncrementWorkflowConsecutiveJobFailuresCount", reflect.TypeOf((*MockRepository)(nil).IncrementWorkflowConsecutiveJobFailuresCount), ctx, workflowID, userID)
}

// ListWorkflows mocks base method.
func (m *MockRepository) ListWorkflows(ctx context.Context, userID, cursor string, filters *workflows.ListWorkflowsFilters) (*workflows.ListWorkflowsResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListWorkflows", ctx, userID, cursor, filters)
	ret0, _ := ret[0].(*workflows.ListWorkflowsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListWorkflows indicates an expected call of ListWorkflows.
func (mr *MockRepositoryMockRecorder) ListWorkflows(ctx, userID, cursor, filters any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkflows", reflect.TypeOf((*MockRepository)(nil).ListWorkflows), ctx, userID, cursor, filters)
}

// ResetWorkflowConsecutiveJobFailuresCount mocks base method.
func (m *MockRepository) ResetWorkflowConsecutiveJobFailuresCount(ctx context.Context, workflowID, userID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResetWorkflowConsecutiveJobFailuresCount", ctx, workflowID, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// ResetWorkflowConsecutiveJobFailuresCount indicates an expected call of ResetWorkflowConsecutiveJobFailuresCount.
func (mr *MockRepositoryMockRecorder) ResetWorkflowConsecutiveJobFailuresCount(ctx, workflowID, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResetWorkflowConsecutiveJobFailuresCount", reflect.TypeOf((*MockRepository)(nil).ResetWorkflowConsecutiveJobFailuresCount), ctx, workflowID, userID)
}

// TerminateWorkflow mocks base method.
func (m *MockRepository) TerminateWorkflow(ctx context.Context, workflowID, userID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TerminateWorkflow", ctx, workflowID, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// TerminateWorkflow indicates an expected call of TerminateWorkflow.
func (mr *MockRepositoryMockRecorder) TerminateWorkflow(ctx, workflowID, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TerminateWorkflow", reflect.TypeOf((*MockRepository)(nil).TerminateWorkflow), ctx, workflowID, userID)
}

// UpdateWorkflow mocks base method.
func (m *MockRepository) UpdateWorkflow(ctx context.Context, workflowID, userID, name, payload string, interval, maxConsecutiveJobFailuresAllowed int32) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWorkflow", ctx, workflowID, userID, name, payload, interval, maxConsecutiveJobFailuresAllowed)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWorkflow indicates an expected call of UpdateWorkflow.
func (mr *MockRepositoryMockRecorder) UpdateWorkflow(ctx, workflowID, userID, name, payload, interval, maxConsecutiveJobFailuresAllowed any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWorkflow", reflect.TypeOf((*MockRepository)(nil).UpdateWorkflow), ctx, workflowID, userID, name, payload, interval, maxConsecutiveJobFailuresAllowed)
}

// UpdateWorkflowBuildStatus mocks base method.
func (m *MockRepository) UpdateWorkflowBuildStatus(ctx context.Context, workflowID, userID, buildStatus string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWorkflowBuildStatus", ctx, workflowID, userID, buildStatus)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWorkflowBuildStatus indicates an expected call of UpdateWorkflowBuildStatus.
func (mr *MockRepositoryMockRecorder) UpdateWorkflowBuildStatus(ctx, workflowID, userID, buildStatus any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWorkflowBuildStatus", reflect.TypeOf((*MockRepository)(nil).UpdateWorkflowBuildStatus), ctx, workflowID, userID, buildStatus)
}

// MockCache is a mock of Cache interface.
type MockCache struct {
	ctrl     *gomock.Controller
	recorder *MockCacheMockRecorder
	isgomock struct{}
}

// MockCacheMockRecorder is the mock recorder for MockCache.
type MockCacheMockRecorder struct {
	mock *MockCache
}

// NewMockCache creates a new mock instance.
func NewMockCache(ctrl *gomock.Controller) *MockCache {
	mock := &MockCache{ctrl: ctrl}
	mock.recorder = &MockCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCache) EXPECT() *MockCacheMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockCache) Delete(ctx context.Context, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockCacheMockRecorder) Delete(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCache)(nil).Delete), ctx, key)
}

// DeleteByPattern mocks base method.
func (m *MockCache) DeleteByPattern(ctx context.Context, pattern string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteByPattern", ctx, pattern)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteByPattern indicates an expected call of DeleteByPattern.
func (mr *MockCacheMockRecorder) DeleteByPattern(ctx, pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteByPattern", reflect.TypeOf((*MockCache)(nil).DeleteByPattern), ctx, pattern)
}

// Get mocks base method.
func (m *MockCache) Get(ctx context.Context, key string, dest any) (any, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key, dest)
	ret0, _ := ret[0].(any)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCacheMockRecorder) Get(ctx, key, dest any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCache)(nil).Get), ctx, key, dest)
}

// Set mocks base method.
func (m *MockCache) Set(ctx context.Context, key string, value any, expiration time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", ctx, key, value, expiration)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockCacheMockRecorder) Set(ctx, key, value, expiration any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCache)(nil).Set), ctx, key, value, expiration)
}

// MockContainerSvc is a mock of ContainerSvc interface.
type MockContainerSvc struct {
	ctrl     *gomock.Controller
	recorder *MockContainerSvcMockRecorder
	isgomock struct{}
}

// MockContainerSvcMockRecorder is the mock recorder for MockContainerSvc.
type MockContainerSvcMockRecorder struct {
	mock *MockContainerSvc
}

// NewMockContainerSvc creates a new mock instance.
func NewMockContainerSvc(ctrl *gomock.Controller) *MockContainerSvc {
	mock := &MockContainerSvc{ctrl: ctrl}
	mock.recorder = &MockContainerSvcMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContainerSvc) EXPECT() *MockContainerSvcMockRecorder {
	return m.recorder
}

// Build mocks base method.
func (m *MockContainerSvc) Build(ctx context.Context, imageName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Build", ctx, imageName)
	ret0, _ := ret[0].(error)
	return ret0
}

// Build indicates an expected call of Build.
func (mr *MockContainerSvcMockRecorder) Build(ctx, imageName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Build", reflect.TypeOf((*MockContainerSvc)(nil).Build), ctx, imageName)
}

// Execute mocks base method.
func (m *MockContainerSvc) Execute(ctx context.Context, timeout time.Duration, image string, cmd, env []string) (string, <-chan *jobs.JobLog, <-chan error, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, timeout, image, cmd, env)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(<-chan *jobs.JobLog)
	ret2, _ := ret[2].(<-chan error)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// Execute indicates an expected call of Execute.
func (mr *MockContainerSvcMockRecorder) Execute(ctx, timeout, image, cmd, env any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockContainerSvc)(nil).Execute), ctx, timeout, image, cmd, env)
}

// Terminate mocks base method.
func (m *MockContainerSvc) Terminate(ctx context.Context, containerID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Terminate", ctx, containerID)
	ret0, _ := ret[0].(error)
	return ret0
}

// Terminate indicates an expected call of Terminate.
func (mr *MockContainerSvcMockRecorder) Terminate(ctx, containerID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Terminate", reflect.TypeOf((*MockContainerSvc)(nil).Terminate), ctx, containerID)
}

// MockHeartBeatSvc is a mock of HeartBeatSvc interface.
type MockHeartBeatSvc struct {
	ctrl     *gomock.Controller
	recorder *MockHeartBeatSvcMockRecorder
	isgomock struct{}
}

// MockHeartBeatSvcMockRecorder is the mock recorder for MockHeartBeatSvc.
type MockHeartBeatSvcMockRecorder struct {
	mock *MockHeartBeatSvc
}

// NewMockHeartBeatSvc creates a new mock instance.
func NewMockHeartBeatSvc(ctrl *gomock.Controller) *MockHeartBeatSvc {
	mock := &MockHeartBeatSvc{ctrl: ctrl}
	mock.recorder = &MockHeartBeatSvcMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHeartBeatSvc) EXPECT() *MockHeartBeatSvcMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockHeartBeatSvc) Execute(ctx context.Context, timeout time.Duration, endpoint string, expectedStatusCode int, headers map[string][]string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, timeout, endpoint, expectedStatusCode, headers)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockHeartBeatSvcMockRecorder) Execute(ctx, timeout, endpoint, expectedStatusCode, headers any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockHeartBeatSvc)(nil).Execute), ctx, timeout, endpoint, expectedStatusCode, headers)
}
